---
title: Longest path in a DAG
subtitle: Assignment of Graph Theory and Algorithms
author: Alessandro Bregoli
header-includes:
  - \usepackage{algpseudocode, algorithm}
...



# Notation

A **directed graph** $G=(V,E)$ is composed by a finite set of **nodes** $V$ and a finite set of
**edges** $E$ such that $E \subseteq [V]^2$. A graph is weighted if there is a function 
$w : E\rightarrow \mathbb{R}$. Given two nodes $x,y \in V$  we say that $x$ is
**adjacent** to $y$ if $\{x,y\} \in E$. This relation isn't symmetric. A **path** is a sequence of
adjacent vertices $\langle v_1,v_2,...,v_k\rangle : v_i \in V \land \{v_i, v_{i+1}\}\in E$. The
**weight** of a path is equal to the number of edges in the case of a non-weighted graph while it is
equal to the sum of the weights of the arcs in the case of a weighted graph. 
A path is **simple** if all vertices in the path are distinct. A path for a **cycle** if 
$v_0 =v_k$ and the path contains at least one edge. A Directed Acyclic Graph (**DAG**) is a
directed graph without cycles of any length. A **shortest simple path** is a simple path of minimal
weight. Conversely, a **longest simple path** is a simple path of maximum weight.

# Single source longest simple path problem

The single source shortest path problem can be solved in polynomial time for each graph. On the
other hand, the single source longest simple path is NP-hard for a generic graph. However, if we
only want to solve the problem for directed acyclic graphs we can modify the algorithm for finding
the single source shortest path in a convenient way and identify the single source simple longest
path in linear time.

## The algorithm

Both the single source shortest path and the single source longest path for a directed acyclic
graph are based on two components: a relax procedure and a topological sort algorithm. The only
difference between the two algorithms is the definition of the relax function.

- **Relax procedure for the single source shortest path algorithm**. The process of relaxing an
  edge $(u,v)$ consists of testing whether we can improve the shortest path to $v$ found, so that
  far by going through $u$ and, if so, updating the shortest path.
- **Relax procedure for the single source longest simple path algorithm**. The process of relaxing
  an edge $(u,v)$ consists of testing whether we can improve the longest path to $v$ found, so that
  far by going through $u$ and, if so, updating the longest path. (Algorithm \ref{algorithm_relax})

\begin{algorithm}
  \caption{RELAX function}
  \label{algorithm_relax}
  \begin{algorithmic}[1]
    \Function{relax}{$v,w \in G.V$, $w$: edge weight}
      \If{$v$.longest\_path < $u$.longest\_path + $w$($u$,$v$)}
        \State $v$.longest\_path = $u$.longest\_path + $w$($u$,$v$)
        \State $v$.predecessor = $u$
      \EndIf
    \EndFunction
  \end{algorithmic}
\end{algorithm}


The **topological sort algorithm** is an algorithm witch find an order among the nodes such that,
  if there is and edge $(u,v)$ then $u$ appear before $v$ in the topological ordering. As shown in
    \ref{algorithm_topological_sort}) , the topological ordering is based on the DFS-visit and
    inherits its computational complexity.   


\begin{algorithm}
  \caption{TOPOLOGICAL SORT}
  \label{algorithm_topological_sort}
  \begin{algorithmic}[1]
  \Function{topological\_sort}{$G$}
    \State topological\_order = \Call{list()}{}
    \For{each $u \in G.V$}
      \State $u.color = WHITE$
      \State $u.predecessor = NIL$
    \EndFor
    \For{each $u \in G.V$}
      \If{$u.color == WHITE$}
        \State \Call{DFS-VISIT}{$G$, $u$, topological\_order}
      \EndIf
    \EndFor
    \State \Return topological\_order
  \EndFunction
  
  \item[]
  
  \Function{DFS-VISIT}{$G$, $u$, topological\_order}
    \State u.color = GRAY

    \For{each $v\in G.Adj[u]$}
      \If{$v.color == WHITE$}
        \State $v.predecessor = u$
        DFS-VISIT($G$, $v$, topological\_order)
      \EndIf
    \EndFor
    \State $u.color = BLACK$
    \State topological\_order.prepend($u$)
  \EndFunction
  \end{algorithmic}
\end{algorithm}


\begin{algorithm}
  \caption{Single source shortest path}
  \label{algorithm_shortest_path}
  \begin{algorithmic}[1]
    \Function{dag-longest-paths}{$G$, $s$}
    \State T = \Call{topological\_sort}{$G$}
    \For{$v \in G\setminus s$}
      \State $v$.longest\_path = $-\infty$
    \EndFor
    \For{$v \in G$}
      \State $v$.predecessor = NILL
    \EndFor
    \State $s$.longest\_path = 0
    \For{$u \in T$}
      \For{$v \in G.Adj[u]$}
        \State \Call{relax}{$u$,$v$,$w$}
      \EndFor
    \EndFor
    
    \EndFunction
  \end{algorithmic}
\end{algorithm}

By exploiting the topological ordering it is possible to define the **single source longest path**
**algorithm** as shown in Algorithm \ref{algorithm_shortest_path}.
The rationale behind this algorithm is based on the fact that there are no cycles in a DAG.
Consequently if the dag contains a path from vertex $u$ to vertex $v$, then $u$ precedes $v$ in the
topological sort. For this reason it is sufficient to make just one pass over the vertices in the
topologically sorted order.

## Time Complexity

The goal of this subsection is to show the linear complexity of the single source longest path
algorithm. In order to achieve this goal we can split the algorithm in its main components
described in Algorithm \ref{algorithm_relax}, Algorithm \ref{algorithm_topological_sort, than
combined together in Algorithm \ref{algorithm_shortest_path}




